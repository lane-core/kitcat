Lane Biocini
February 2025

Magmoids and the structures we can characterize within them.

We compile all the definitions into a module meant to instantiate uniform definitions
for any category-like (i.e. magmoidal) structure; we also even have the machinery
for heteromorphisms between structures that only agree in being magmoidal,
see the definitions for functor, adjunctions, nat-trans, etc.

```agda
{-# OPTIONS --safe --erased-cubical --no-guardedness --no-sized-types #-}

open import Cat.Magmoid.Type
import Cat.Magmoid.Data.Base as M

module Cat.Magmoid.Data.Neutral (M : Magmoids) where

open import Core.Type
open import Core.Base
open import Core.Data.Sigma
open import Core.Data.Nat
open import Core.HLevel
open import Core.Kan
open import Core.Transport
open import Core.Equiv

open M M

module _ {x y} (f : hom x y) where
  is-left-divisible : Type (o ⊔ h)
  is-left-divisible = ∀ {w} → is-equiv (λ (h : hom w x) → h ⨾ f)

  is-right-divisible : Type (o ⊔ h)
  is-right-divisible = ∀ {z} → is-equiv (λ (g : hom y z) → f ⨾ g)

divl→rcancel
  : ∀ {w x y} {g : hom x y} {h₁ h₂ : hom w x}
  → (is-left-divisible g)
  → h₁ ⨾ g ≡ h₂ ⨾ g → h₁ ≡ h₂
divl→rcancel {g = g} {h₁} {h₂} e σ =
  ap fst (is-contr→is-prop (e .eqv-fibers (h₂ ⨾ g))
    (h₁ , σ) (h₂ , refl))

divr→lcancel
  : ∀ {x y z} {f : hom x y} {k₁ k₂ : hom y z}
  → (is-right-divisible f)
  → f ⨾ k₁ ≡ f ⨾ k₂ → k₁ ≡ k₂
divr→lcancel {f = f} {k₁} {k₂} e σ =
  ap fst (is-contr→is-prop (e .eqv-fibers (f ⨾ k₂))
    (k₁ , σ) (k₂ , refl))

is-neutral : ∀ {x y} → hom x y → Type (o ⊔ h)
is-neutral {x} {y} f =
  is-left-divisible f × is-right-divisible f

is-neutral-is-prop
  : ∀ {x y} (f : hom x y) → is-prop (is-neutral f)
is-neutral-is-prop f = is-prop-×
  (Πi-is-prop λ _ → is-equiv-is-prop _) (Πi-is-prop λ _ → is-equiv-is-prop _)

module is-neutral {x y} {f : hom x y} (e : is-neutral f) where
  divl : ∀ {z} → hom x z → hom y z
  divl = Equiv.inv (f ⨾_ , e .snd)

  divr : ∀ {w} → hom w y → hom w x
  divr = Equiv.inv (_⨾ f , e .fst)

  divl-equiv : ∀ {z} → is-equiv (divl {z})
  divl-equiv = sym-equiv (e .snd)

  divr-equiv : ∀ {w} → is-equiv (divr {w})
  divr-equiv = sym-equiv (e .fst)

  loop : hom y y
  loop = divl f

  coloop : hom x x
  coloop = divr f

  pre-counit : ∀ {z} (g : hom x z)
    → f ⨾ divl g ≡ g
  pre-counit = Equiv.counit (f ⨾_ , e .snd)

  post-counit : ∀ {w} (g : hom w y)
    → divr g ⨾ f ≡ g
  post-counit = Equiv.counit (_⨾ f , e .fst)

  pre-unit : ∀ {z} (g : hom y z)
    → divl (f ⨾ g) ≡ g
  pre-unit = Equiv.unit (f ⨾_ , e .snd)

  post-unit : ∀ {w} (g : hom w x)
    → divr (g ⨾ f) ≡ g
  post-unit = Equiv.unit (_⨾ f , e .fst)

module _ {x} (e : hom x x) where
  lunital runital : Type (o ⊔ h)
  lunital = ∀ {y} (f : hom x y)
    → e ⨾ (e ⨾ f) ≡ e ⨾ f
  runital = ∀ {w} (f : hom w x)
    → (f ⨾ e) ⨾ e ≡ f ⨾ e

  record is-unital : Type (o ⊔ h) where
    field
      neutral : is-neutral e
      lcoh : lunital
      rcoh : runital

unital : ∀ x → Type (o ⊔ h)
unital x = Σ i ∶ hom x x , is-unital i

-- Kraus's notion is the finest equivalence relation (without
-- associativity it is only an embedding into wild equivalences
-- defined with is-biinv, with assoc it is equivalent) which is
-- general enough to be defined in any magmoid structure
_≐_ : ob → ob → Type (o ⊔ h)
_≐_ x y = Σ f ∶ hom x y , is-neutral f

neu-refl : ∀ {x} → unital x → x ≐ x
neu-refl (i , p) .fst = i
neu-refl (i , p) .snd .fst = is-unital.neutral p .fst
neu-refl (i , p) .snd .snd = is-unital.neutral p .snd

-- The minimal associativity needed to invert a neutral morphism,
-- expressed as a type former over target-based morphisms. Each
-- component pins one of the three morphisms generated by the neutral
-- structure (e, loop, divr loop) in the middle position; the outer
-- slots are derived from f and g via divr and pre-composition with e.
right-neutral-coherent
  : ∀ {a b} {e : hom a b} → is-neutral e
  → ∀ {w z} → hom w b → hom b z → Type h
right-neutral-coherent {e = e} n f g =
    associator (divr f) e g
  × associator f loop g
  × associator f (divr loop) (e ⨾ g)
  where open is-neutral n

-- Thunkable decomposition of right-neutral-coherent: quantify out g.
-- Each structural morphism (e, loop, divr loop) is a thunkable pivot.
neutral-thunkable
  : ∀ {a b} {e : hom a b} → is-neutral e → ∀ {w} → hom w b → Type (o ⊔ h)
neutral-thunkable {e = e} n f =
    thunkable (divr f) e
  × thunkable f loop
  × thunkable f (divr loop)
  where open is-neutral n

-- Linear decomposition: dual structure using source-side morphisms.
-- Each structural morphism (e, coloop, divl coloop) is a linear pivot.
neutral-linear
  : ∀ {a b} {e : hom a b} → is-neutral e → ∀ {z} → hom a z → Type (o ⊔ h)
neutral-linear {e = e} n g =
    linear (divl g) e
  × linear g coloop
  × linear g (divl coloop)
  where open is-neutral n

-- Source-based coherence, dual to right-neutral-coherent.
-- Uses divl structure (coloop, divl coloop) instead of divr (loop, divr loop).
left-neutral-coherent
  : ∀ {a b} {e : hom a b} → is-neutral e
  → ∀ {w z} → hom w a → hom a z → Type h
left-neutral-coherent {e = e} n f g =
    associator f e (divl g)
  × associator f coloop g
  × associator (f ⨾ e) (divl coloop) g
  where open is-neutral n

module right-neutral-coherent {a b} {e : hom a b} (n : is-neutral e)
  (coh : ∀ {w z} (f : hom w b) (g : hom b z)
    → right-neutral-coherent n f g) where

  open is-neutral n

  private
    assoc-e
      : ∀ {w z} (f : hom w a) (g : hom b z)
      → associator f e g
    assoc-e f g = subst (λ h → associator h e g)
      (post-unit f) (coh (f ⨾ e) g .fst)

    assoc-loop
      : ∀ {w z} (f : hom w b) (g : hom b z)
      → associator f loop g
    assoc-loop f g = coh f g .snd .fst

    assoc-inv
      : ∀ {w z} (f : hom w b) (g : hom a z)
      → associator f (divr loop) g
    assoc-inv f g = subst (λ h → associator f (divr loop) h)
      (pre-counit g) (coh f (divl g) .snd .snd)

  private
    p0 : e ⨾ loop ≡ e
    p0 = pre-counit e

    p1 : divr loop ⨾ e ≡ loop
    p1 = post-counit loop

    e0 : ∀ {w} → is-equiv (λ (k : hom w b) → k ⨾ loop)
    e0 {w} = 3-for-2-right
      {f = λ (k : hom w a) → k ⨾ e}
      {g = λ (k : hom w b) → k ⨾ loop}
      (n .fst)
      (subst is-equiv
        (funext λ k → ap (k ⨾_) (sym p0) ∙ assoc-e k loop)
        (n .fst))

    e1 : ∀ {z} → is-equiv (λ (g : hom b z) → loop ⨾ g)
    e1 {z} = 3-for-2-left
      {f = λ (g : hom b z) → loop ⨾ g}
      {g = λ (g : hom b z) → e ⨾ g}
      (n .snd)
      (subst is-equiv
        (funext λ g → sym (assoc-loop e g ∙ ap (_⨾ g) p0))
        (n .snd))

  neu-sym : b ≐ a
  neu-sym .fst = divr loop
  neu-sym .snd .fst {w} = 3-for-2-left
    {f = λ (k : hom w b) → k ⨾ divr loop}
    {g = λ (k : hom w a) → k ⨾ e}
    (n .fst)
    (subst is-equiv
      (funext λ k → ap (k ⨾_) (sym p1) ∙ assoc-inv k e)
      e0)
  neu-sym .snd .snd {z} = 3-for-2-right
    {f = λ (g : hom b z) → e ⨾ g}
    {g = λ (g : hom a z) → divr loop ⨾ g}
    (n .snd)
    (subst is-equiv
      (funext λ g₀ →
        ap (_⨾ g₀) (sym p1) ∙ sym (assoc-e (divr loop) g₀))
      e1)

  inv-unique : divr loop ≡ divl coloop
  inv-unique = divr→lcancel (n .snd)
    (step-a ∙ sym (pre-counit coloop)) where
    step-a : e ⨾ divr loop ≡ coloop
    step-a = divl→rcancel (n .fst)
      (sym (assoc-inv e e)
        ∙ ap (e ⨾_) p1 ∙ p0 ∙ sym (post-counit e))

  to-thunkable : ∀ {w} (f : hom w b) → neutral-thunkable n f
  to-thunkable f .fst g = coh f g .fst
  to-thunkable f .snd .fst g = coh f g .snd .fst
  to-thunkable f .snd .snd h = subst (associator f (divr loop))
    (pre-counit h) (coh f (divl h) .snd .snd)

module left-neutral-coherent {a b} {e : hom a b} (n : is-neutral e)
  (coh : ∀ {w z} (f : hom w a) (g : hom a z)
    → left-neutral-coherent n f g) where

  open is-neutral n

  private
    assoc-e
      : ∀ {w z} (f : hom w a) (h : hom b z)
      → associator f e h
    assoc-e f h = subst (associator f e)
      (pre-unit h) (coh f (e ⨾ h) .fst)

    assoc-coloop
      : ∀ {w z} (f : hom w a) (g : hom a z)
      → associator f coloop g
    assoc-coloop f g = coh f g .snd .fst

    assoc-inv
      : ∀ {w z} (h : hom w b) (g : hom a z)
      → associator h (divl coloop) g
    assoc-inv h g = subst (λ x → associator x (divl coloop) g)
      (post-counit h) (coh (divr h) g .snd .snd)

  private
    q0 : coloop ⨾ e ≡ e
    q0 = post-counit e

    q1 : e ⨾ divl coloop ≡ coloop
    q1 = pre-counit coloop

    e0 : ∀ {w} → is-equiv (λ (k : hom w a) → k ⨾ coloop)
    e0 {w} = 3-for-2-left
      {f = λ (k : hom w a) → k ⨾ coloop}
      {g = λ (k : hom w a) → k ⨾ e}
      (n .fst)
      (subst is-equiv
        (funext λ k → ap (k ⨾_) (sym q0) ∙ assoc-coloop k e)
        (n .fst))

    e1 : ∀ {z} → is-equiv (λ (g : hom a z) → coloop ⨾ g)
    e1 {z} = 3-for-2-right
      {f = λ (g : hom b z) → e ⨾ g}
      {g = λ (g : hom a z) → coloop ⨾ g}
      (n .snd)
      (subst is-equiv
        (funext λ g → sym (assoc-e coloop g ∙ ap (_⨾ g) q0))
        (n .snd))

  neu-sym : b ≐ a
  neu-sym .fst = divl coloop
  neu-sym .snd .fst {w} = 3-for-2-right
    {f = λ (k : hom w a) → k ⨾ e}
    {g = λ (k : hom w b) → k ⨾ divl coloop}
    (n .fst)
    (subst is-equiv
      (funext λ k → ap (k ⨾_) (sym q1) ∙ assoc-e k (divl coloop))
      e0)
  neu-sym .snd .snd {z} = 3-for-2-left
    {f = λ (g : hom a z) → divl coloop ⨾ g}
    {g = λ (g : hom b z) → e ⨾ g}
    (n .snd)
    (subst is-equiv
      (funext λ g₀ →
        ap (_⨾ g₀) (sym q1) ∙ sym (assoc-inv e g₀))
      e1)

  inv-unique : divl coloop ≡ divr loop
  inv-unique = divl→rcancel (n .fst)
    (step-a ∙ sym (post-counit loop)) where
    step-a : divl coloop ⨾ e ≡ loop
    step-a = divr→lcancel (n .snd)
      (assoc-inv e e
        ∙ ap (_⨾ e) q1 ∙ q0 ∙ sym (pre-counit e))

  to-linear : ∀ {z} (g : hom a z) → neutral-linear n g
  to-linear g .fst f = coh f g .fst
  to-linear g .snd .fst f = coh f g .snd .fst
  to-linear g .snd .snd f = subst (λ x → associator x (divl coloop) g)
    (post-counit f) (coh (divr f) g .snd .snd)

module neutral-thunkable {a b} {e : hom a b} (n : is-neutral e)
  (th : ∀ {w} (f : hom w b) → neutral-thunkable n f)
  where

  open is-neutral n

  private
    p0 : e ⨾ loop ≡ e
    p0 = pre-counit e

    p1 : divr loop ⨾ e ≡ loop
    p1 = post-counit loop

  private
    e1 : ∀ {z} → is-equiv (λ (g : hom b z) → loop ⨾ g)
    e1 {z} = 3-for-2-left
      {f = λ (g : hom b z) → loop ⨾ g}
      {g = λ (g : hom b z) → e ⨾ g}
      (n .snd)
      (subst is-equiv
        (funext λ g → sym (th e .snd .fst g ∙ ap (_⨾ g) p0))
        (n .snd))

  rdiv : is-right-divisible (divr loop)
  rdiv {z} = 3-for-2-right
    {f = λ (g : hom b z) → e ⨾ g}
    {g = λ (g : hom a z) → divr loop ⨾ g}
    (n .snd)
    (subst is-equiv
      (funext λ g₀ →
        ap (_⨾ g₀) (sym p1) ∙ sym (th loop .fst g₀))
      e1)

module neutral-linear {a b} {e : hom a b} (n : is-neutral e)
  (ln : ∀ {z} (g : hom a z) → neutral-linear n g)
  where

  open is-neutral n
  private
    q0 : coloop ⨾ e ≡ e
    q0 = post-counit e

    q1 : e ⨾ divl coloop ≡ coloop
    q1 = pre-counit coloop

  private
    e1' : ∀ {w} → is-equiv (λ (k : hom w a) → k ⨾ coloop)
    e1' {w} = 3-for-2-left
      {f = λ (k : hom w a) → k ⨾ coloop}
      {g = λ (k : hom w a) → k ⨾ e}
      (n .fst)
      (subst is-equiv
        (funext λ k → ap (k ⨾_) (sym q0) ∙ ln e .snd .fst k)
        (n .fst))

  ldiv : is-left-divisible (divl coloop)
  ldiv {w} = 3-for-2-right
    {f = λ (k : hom w a) → k ⨾ e}
    {g = λ (k : hom w b) → k ⨾ divl coloop}
    (n .fst)
    (subst is-equiv
      (funext λ k → ap (k ⨾_) (sym q1) ∙ ln coloop .fst k)
      e1')

-- The associativity data needed to compose neutral morphisms:
-- g linear at f, and f thunkable at g.
comp-coherent
  : ∀ {a b c} (f : hom a b) (g : hom b c) → Type (o ⊔ h)
comp-coherent f g = linear g f × thunkable f g

module comp-coherent {a b c} {f : hom a b} {g : hom b c}
  (fn : is-neutral f) (gn : is-neutral g)
  (coh : comp-coherent f g) where

  comp-is-neutral : is-neutral (f ⨾ g)
  comp-is-neutral .fst =
    subst is-equiv (funext (λ h → sym (coh .fst h)))
      (_∙e_ (_⨾ f , fn .fst) (_⨾ g , gn .fst) .snd)
  comp-is-neutral .snd =
    subst is-equiv (funext (λ h → coh .snd h))
      (_∙e_ (g ⨾_ , gn .snd) (f ⨾_ , fn .snd) .snd)

module associative (assoc : associativity) where
  comp-is-neutral
    : ∀ {a b c} {f : hom a b} {g : hom b c}
    → is-neutral f → is-neutral g → is-neutral (_⨾_ f g)
  comp-is-neutral {f} {g} fe ge = m.comp-is-neutral where
    module m = comp-coherent fe ge
      ((λ h → assoc h f g) , (λ k → assoc f g k))

  neu-cat :  ∀ {a b c} → a ≐ b → b ≐ c → a ≐ c
  neu-cat e d .fst = e .fst ⨾ d .fst
  neu-cat e d .snd = comp-is-neutral (e .snd) (d .snd)

  neu-sym : ∀ {a b} → a ≐ b → b ≐ a
  neu-sym (e , n) = m.neu-sym where
    open is-neutral n
    coh : ∀ {w z} (f : hom w _) (g : hom _ z)
      → right-neutral-coherent n f g
    coh f g = assoc (divr f) e g , assoc f loop g
      , assoc f (divr loop) (e ⨾ g)
    module m = right-neutral-coherent n coh

  neu-assoc
    : ∀ {w x y z} (a : w ≐ x) (b : x ≐ y) (c : y ≐ z)
    → neu-cat (neu-cat a b) c ≡ neu-cat a (neu-cat b c)
  neu-assoc a b c i .fst =
    sym (assoc (a .fst) (b .fst) (c .fst)) i
  neu-assoc a b c i .snd = is-prop→PathP
    (λ i → is-neutral-is-prop
      (sym (assoc (a .fst) (b .fst) (c .fst)) i))
    (neu-cat (neu-cat a b) c .snd)
    (neu-cat a (neu-cat b c) .snd) i

